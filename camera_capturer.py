# This module defines the CameraCapturer class and its methods

import logging

import numpy as np
from cv2 import cv2 as cv


class CameraCapturer(object):
    """ A class to acquire images from the camera.

    Attributes:
        cap: the VideoCapture instance of opencv
        width: the width of image captured
        height: the height of image captured
    """

    cap = None
    rectify_distortion = True
    camera = ""
    width = 0
    height = 0

    def __init__(self, camera, rectify_distortion=True):
        """ Initialize the instance by the selection of the camera.

        Args:
            camera: "front" standing for front camera or "rear" standing for
            rear camera.
        """
        if camera == "front":
            self.cap = cv.VideoCapture(1)
        elif camera == "rear":
            self.cap = cv.VideoCapture(0)
        else:
            self.cap = None

        self.width = int(self.cap.get(cv.CAP_PROP_FRAME_WIDTH))
        self.height = int(self.cap.get(cv.CAP_PROP_FRAME_HEIGHT))

        self.rectify_distortion = rectify_distortion

        self.camera = camera

    def __del__(self):
        """ Release the VideoCapture instance when deleted.

        Args:
            None

        Returns:
            None
        """
        if self.cap is not None:
            self.cap.release()
        else:
            pass

    def get_frame(self):
        """ Catch the frame captured by the camera.

        Args:
            None

        Returns:
            frame: the frame captured by the camera
        """
        _, frame = self.cap.read()

        if self.rectify_distortion is True:
            if self.camera == "front":
                frame = self.front_distortion_rectify(frame)
            elif self.camera == "rear":
                frame = self.rear_distortion_rectify(frame)

        return frame

    def front_distortion_rectify(self, img):
        """Calibrate the distortion of front camera.

        According to the camera parameters calculated bt Matlab, apply the
        calibration for the image catched by the front camera. Note that the
        result obtained by OpenCV is not as good as the one obtained by Matlab.
        So it can be further improved.

        Args:
            img: the image catched by the front camera.

        Returns:
            calibrated_img: the image having been calibrated
        """

        # The following parameters are generated by Matlab
        return img

        # Fianlly we decided to use original image without calibration.

        # camera_matrix = np.array(
        #     [[889.4856, 0, 0],
        #      [0, 887.7704, 0],
        #      [695.6208, 315.6104, 1]])

        # camera_matrix = camera_matrix.T
        # distortion_coeffs = np.array([-0.4161, 0.2507, 0, 0]).reshape(-1, 1)

        # # Apply the calibration
        # dims = (img.shape[1], img.shape[0])
        # map1, map2 = cv.initUndistortRectifyMap(
        #     camera_matrix,
        #     distortion_coeffs,
        #     np.eye(3),
        #     camera_matrix,
        #     dims,
        #     cv.CV_32FC1)

        # calibrated_img = cv.remap(
        #     img, map1, map2,
        #     interpolation=cv.INTER_LINEAR, borderMode=cv.BORDER_CONSTANT)

        # return calibrated_img

    def rear_distortion_rectify(self, img):
        """Calibrate the distortion of rear camera.

        According to the camera parameters calculated bt Matlab, apply the
        calibration for the image catched by the rear camera. Note that the
        result obtained by OpenCV is not as good as the one obtained by Matlab.
        So it can be further improved.

        Args:
            img: the image catched by the rear camera.

        Returns:
            calibrated_img: the image having been calibrated
        """
        # The following parameters are generated by Matlab
        return img

        # Fianlly we decided to use original image without calibration.

        # camera_matrix = np.array(
        #     [[332.78, 0, 0],
        #      [0, 332.712, 0],
        #      [308.47, 223.76, 1]])

        # camera_matrix = camera_matrix.T
        # distortion_coeffs = np.array([-0.3420, 0.12827, 0, 0, 0]).reshape(-1, 1)

        # # Apply the calibration
        # dims = (img.shape[1], img.shape[0])
        # map1, map2 = cv.initUndistortRectifyMap(
        #     camera_matrix,
        #     distortion_coeffs,
        #     np.eye(3),
        #     camera_matrix,
        #     dims,
        #     cv.CV_32FC1)

        # calibrated_img = cv.remap(
        #     img, map1, map2,
        #     interpolation=cv.INTER_LINEAR, borderMode=cv.BORDER_CONSTANT)

        # return calibrated_img
