from cv2 import cv2 as cv
import numpy as np


def binarize(img):
    """Binarize a grayscale image.

    Binarize the input grayscale image by ostu threshold method.

    Args:
        img: an image. Grayscale image is preffered.

    Returns:
       img_binary: the binarized image
    """

    # Make sure that img_gray is a grayscale image.
    if len(img.shape) == 2:
        img_gray = img
    elif len(img.shape) == 3 and img.shape[2] == 3:
        img_gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
    else:
        print("Converting image failed:", img.shape)
        return None
    # Apply the threshold method. It can be improved by changing the arguments.
    _, img_binary = cv.threshold(
        img, 150, 255, cv.THRESH_BINARY, cv.THRESH_OTSU)

    return img_binary


def front_distortion_rectify(img):
    """Calibrate the distortion of front camera.

    According to the camera parameters calculated bt Matlab, apply the
    calibration for the image catched by the front camera. Note that the
    result obtained by OpenCV is not as good as the one obtained by Matlab. So
    it can be further improved.

    Args:
        img: the image catched by the front camera.

    Returns:
        calibrated_img: the image having been calibrated
    """

    # The following parameters are generated by Matlab
    camera_matrix = np.array(
        [[889.4856, 0, 0],
         [0, 887.7704, 0],
         [695.6208, 315.6104, 1]])

    camera_matrix = camera_matrix.T
    distortion_coeffs = np.array([-0.4161, 0.2507, 0, 0]).reshape(-1, 1)

    # Apply the calibration
    dims = (img.shape[1], img.shape[0])
    map1, map2 = cv.initUndistortRectifyMap(
        camera_matrix,
        distortion_coeffs,
        np.eye(3),
        camera_matrix,
        dims,
        cv.CV_32FC1)

    calibrated_img = cv.remap(
        img, map1, map2,
        interpolation=cv.INTER_LINEAR, borderMode=cv.BORDER_CONSTANT)

    return calibrated_img
